<!DOCTYPE html>
<html lang="zh-CN">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  <meta name="author" content="隋鑫">
  <meta name="description" content="隋鑫的个人网站">
  <meta name="keywords" content="隋鑫,前端工程师,2020届本科毕业生">
  
  <link rel="prev" href="http://suixin.monster/js%E6%95%B0%E7%BB%84/" />
  <link rel="next" href="http://suixin.monster/js%E8%BF%90%E7%AE%97%E7%AC%A6/" />
  <link rel="canonical" href="http://suixin.monster/js%E5%87%BD%E6%95%B0/" />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           JS函数 | 隋鑫的个人网站
       
  </title>
  <meta name="title" content="JS函数 | 隋鑫的个人网站">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  
  
 

<script type="application/ld+json">
 "@context" : "http://schema.org",
    "@type" : "BlogPosting",
    "mainEntityOfPage": {
         "@type": "WebPage",
         "@id": "http:\/\/suixin.monster\/"
    },
    "articleSection" : "posts",
    "name" : "JS函数",
    "headline" : "JS函数",
    "description" : "函数是一种特殊的对象\n定义一个函数  具名函数  function 函数名(形参1，形参2){ 语句 return 返回值 }  匿名函数（去掉函数名）  let a =function(x,y){ return x\x2by }\/\/也叫函数表达式 note：\nlet a =function fn(x,y){ return x\x2by } fn(1,2)\/\/会报错，因为fn函数在等号右边，则作用域范围只在等号右边  箭头函数  let f1 = x =\x26gt;x*x\/\/箭头左边为输入，右边为输出 f1(9)\/\/输出81 let f2 = (x，y) =\x26gt; x*y\/\/若箭头左边有两个输入参数，需要括号括起来 f2(8,9)\/\/输出72 let f3 = (x，y) =\x26gt; { console.log(\x27hi\x27) return x*y }\/\/若箭头右边有多个语句，必须加花括号和return 返回值 let f4 = x =\x26gt;({ name:x })\/\/若要在箭头右边直接返回一个对象，需要加括号  构造函数（很少用）  let fn1 = new function(\x27x\x27，\x27y\x27, \x27console.",
    "inLanguage" : "zh-CN",
    "author" : "隋鑫",
    "creator" : "隋鑫",
    "publisher": "隋鑫",
    "accountablePerson" : "隋鑫",
    "copyrightHolder" : "隋鑫",
    "copyrightYear" : "2020",
    "datePublished": "2020-02-01 23:57:11 \x2b0800 CST",
    "dateModified" : "2020-02-01 23:57:11 \x2b0800 CST",
    "url" : "http:\/\/suixin.monster\/js%E5%87%BD%E6%95%B0\/",
    "wordCount" : "474",
    "keywords" : [  "隋鑫的个人网站"]
}
</script>

</head>

  


  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://suixin.monster/">隋鑫的个人网站</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="https://juejin.im/user/5c21e27ee51d452f2c2ef72c" title="">掘金</a>
                
                <a class="menu-item" href="/index.xml" title="">RSS</a>
                
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-xihuan"></i></a>&nbsp;<a href="http://suixin.monster/">隋鑫的个人网站</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/" title="">首页</a>
                
                <a class="menu-item" href="/posts/" title="">文章</a>
                
                <a class="menu-item" href="https://juejin.im/user/5c21e27ee51d452f2c2ef72c" title="">掘金</a>
                
                <a class="menu-item" href="/index.xml" title="">RSS</a>
                
        </div>
    </div>
</nav>
    	 <main class="main">
          <div class="container">
      		
<article class="post-warp" itemscope itemtype="http://schema.org/Article">
    <header class="post-header">
        <h1 class="post-title" itemprop="name headline">JS函数</h1>
        <div class="post-meta">
                Written by <a itemprop="name" href="http://suixin.monster/" rel="author">隋鑫</a> with ♥ 
                <span class="post-time">
                on <time datetime=2020-02-01 itemprop="datePublished">February 1, 2020</time>
                </span>
                in
                
        </div>
    </header>
    <div class="post-content">
        

        

        
        
     
          
          
          

          
          
          

          <p>函数是一种特殊的对象</p>
<h2 id="定义一个函数">定义一个函数</h2>
<ul>
<li>具名函数</li>
</ul>
<pre><code>function 函数名(形参1，形参2){
    语句
    return 返回值
}
</code></pre><ul>
<li>匿名函数（去掉函数名）</li>
</ul>
<pre><code>let a =function(x,y){
    return x+y
}//也叫函数表达式
</code></pre><p>note：</p>
<pre><code>let a =function fn(x,y){
    return x+y
}
fn(1,2)//会报错，因为fn函数在等号右边，则作用域范围只在等号右边
</code></pre><ul>
<li>箭头函数</li>
</ul>
<pre><code>let f1 = x =&gt;x*x//箭头左边为输入，右边为输出
f1(9)//输出81
</code></pre><pre><code>let f2 = (x，y) =&gt; x*y//若箭头左边有两个输入参数，需要括号括起来
f2(8,9)//输出72
</code></pre><pre><code>let f3 = (x，y) =&gt; {
    console.log('hi')
    return x*y
}//若箭头右边有多个语句，必须加花括号和return 返回值
</code></pre><pre><code>let f4 = x =&gt;({
    name:x
})//若要在箭头右边直接返回一个对象，需要加括号
</code></pre><ul>
<li>构造函数（很少用）</li>
</ul>
<pre><code>let fn1 = new function('x'，'y',
    'console.log(\'hi\');
    return x*y'
)
</code></pre><p>所有函数都是 Function 构造出来的，包括 Object，Array，Function 都是。</p>
<h2 id="函数自身-v-函数调用">函数自身 v 函数调用</h2>
<ul>
<li>函数自身</li>
</ul>
<pre><code>let fn = () =&gt;console.log('hi')
fn//没有结果，因为fn没有执行(调用)
</code></pre><ul>
<li>函数调用</li>
</ul>
<pre><code>let fn = () =&gt;console.log('hi')
fn()//打印出hi，有圆括号才是调用
</code></pre><pre><code>let fn = () =&gt;console.log('hi')//fn只保存了匿名函数的地址
let fn2 = fn//地址复制给fn2
fn2()//fn和fn2都是匿名函数的引用而已
</code></pre><h2 id="函数的要素">函数的要素</h2>
<ul>
<li>
<p>调用时机</p>
<p>调用时机不同，结果不同</p>
</li>
</ul>
<pre><code>let a = 1
function fn(){
    console.log(a)
}
a = 2
fn()//打印出2
</code></pre><pre><code>let a = 1
function fn(){
  setTimeout(() =&gt; {
    console.log(a)
  },0)
}
fn()
a = 2//先执行完程序，再打印出2
</code></pre><pre><code> let i= 0
 for(i = 0;i &lt; 6;i++){
    setTimeout(() =&gt;{
        console.log(i)
    },0)
 }//打印出6个6，而不是0，1，2，3，4，5
</code></pre><pre><code> for(let i = 0;i &lt; 6;i++){
    setTimeout(() =&gt;{
        console.log(i)
    },0)
 }//打印出0，1，2，3，4，5，因为JS在for和let一起用时会加东西，每次循环会多创建（复制）一个i（迎合新手想法）。
</code></pre><ul>
<li>
<p>作用域</p>
<ul>
<li>全局变量和局部变量</li>
</ul>
<p>在顶级作用域声明的变量就是全局变量，window 的属性是全局变量，其他都局部变量。</p>
<ul>
<li>函数嵌套</li>
</ul>
<pre><code>function f1(){
    let a = 1
    function f2(){
        let a = 2
        console.log(a)
    }
    console.log(a)
    a = 3
    f2()
}
f1()//打印出1，2
</code></pre><p>当多个作用域有同名变量 a，那么查找 a 的声明时，就向上取最近的作用域（就近原则），查找 a 的过程与函数执行无关（静态作用域或词法作用域），但 a 的值和函数执行有关。</p>
</li>
<li>
<p>闭包</p>
<pre><code>  function f1(){
      let a = 1
      function f2(){
          let a = 2
        function f3(){
          console.log(a)
        }
      a = 22
      f3()
  }
  console.log(a)
  a = 100
  f2()
  }
  f1()//打印出1，2
</code></pre><p>如果一个函数用到了外部的变量，那么这个函数加这个变量就叫做闭包，如上面的 a 和 f3 组成了闭包。</p>
</li>
<li>
<p>形式参数</p>
</li>
</ul>
<pre><code>function add(x,y){
    return x+y
}//x和y为形参，因为不是实际的参数
add(1,2)//调用add时，1和2为实参，会被赋值给 x，y
</code></pre><pre><code>function add(){
    var x = arguments[]
    var y = arguments[]
    return x+y
}//形参其实可认为是变量声明
</code></pre><ul>
<li>返回值</li>
</ul>
<p>每个函数都有返回值</p>
<pre><code>function hi(){
    console.log('hi')
}
hi()//返回值为undefined，因为没写return
</code></pre><pre><code>function hi(){
    return console.log('hi')
}
hi()//返回值为console.log('hi')的值，即undefined,只是打印了hi
</code></pre><p>函数执行完后才会返回，只有函数才有返回值。</p>
<ul>
<li>调用栈</li>
</ul>
<ol>
<li>
<p>JS 引擎在调用一个函数前，需要把函数所在的环境 push 到一个数组里，数组即为调用栈。</p>
</li>
<li>
<p>等函数执行完后，就会把环境 pop 出来。</p>
</li>
<li>
<p>然后 return 到之前的环境，继续执行后续代码。</p>
<ul>
<li>
<p>递归函数</p>
<ol>
<li>
<p>阶乘</p>
<pre><code>function f(n){
    return n === 1 ? 1 : n*f(n-1)
}
f(100)//压100次栈
</code></pre></li>
<li>
<p>递归的调用栈最长为</p>
<p>Chrome：12578</p>
<p>Firefox：26773</p>
<p>Node：12536</p>
</li>
<li>
<p>爆栈</p>
<p>调用栈中压入得帧过多，程序会崩溃。</p>
</li>
</ol>
</li>
</ul>
</li>
</ol>
<ul>
<li>函数提升</li>
</ul>
<pre><code>function fn(){}
</code></pre><p>不管将具名函数声明在哪，都会跑到第一行。</p>
<pre><code>let fn = function(){}//为赋值，右边的匿名函数声明不会提升到第一行
</code></pre><ul>
<li><strong>arguments(箭头函数没有)</strong></li>
</ul>
<p>伪数组</p>
<pre><code>Array.from()//可以将伪数组变成数组
</code></pre><ul>
<li>
<p><strong>this(箭头函数没有)</strong>
如果不给任何条件，this 默认指向 window，如果传的不是对象，JS 会自动封装成对象。</p>
<ul>
<li>传 this</li>
</ul>
<pre><code>fn.call(xxx,1,2,3)//传this或arguments
</code></pre><p>如果非要传数字，不想自动封装成对象</p>
<pre><code>function fn(){
    'use strict'
    console.log('this:'+this)
}
</code></pre><p>this 是一个隐藏参数， arguments 是普通参数。</p>
<ul>
<li>
<p>假如没有 this</p>
<pre><code>let person = {
    name: 'frank',
    sayHi(){
        console.log(`你好，我叫` + person.name)
    }
}
//可以直接保存对象地址的变量获取'name',简称引用
</code></pre><ol>
<li>如果 person 改名了，sayHi 函数就挂了。</li>
<li>或者 sayHi 函数有可能在另一个文件里。</li>
<li>而 JS 中 person.sayHi()会隐式地 person 作为 this 传给 sayHi，方便 sayHi 通过 this 获取 person 对应的对象。</li>
</ol>
</li>
<li>
<p>新手调用法</p>
</li>
</ul>
<pre><code>person.sayHi()
//会自动把person传到函数里，作为this
</code></pre><ul>
<li>老手调用法</li>
</ul>
<pre><code>person.sayHi.call(person)
//要手动把person传到函数里，作为this
</code></pre><p>例如：</p>
<pre><code>function add(x,y){
    return x+y
}
add.call(undefined,1,2)//3
</code></pre><p>第一个参数要作为 this，而原函数没有 this，只能用 undefined 占位，null 也可以。</p>
<p>再如：</p>
<pre><code>Array.prototype.forEach2 = function(fn){
    for(let i=0;i&lt;this.length;i++){
        fn(this[i],i)
    }
}
//因为使用forEach2时总会用arr.forEach2,所以arr就被自动传给了forEach2

array.forEach2.call(array,(item)=&gt;console.log(item))
//1,2,3
array.forEach2.call({0:'a',length： 1 },(item)=&gt;console.log(item))
//this不一定是数组
</code></pre><ul>
<li>this 的两种使用方法</li>
</ul>
<ol>
<li>隐式传递</li>
</ol>
<pre><code>fn(1,2)
obj.child.fn(1)
</code></pre><ol start="2">
<li>显示传递</li>
</ol>
<pre><code>fn.call(undefined,1,2)或fn.apply(undefined,[1,2])
//使用apply需要在参数上加中括号[](需要数组形式)
obj.child.fn.call(obj.child,1)
</code></pre><ul>
<li>绑定 this</li>
</ul>
<ol>
<li>使用.bind 可以让 this 不被改变</li>
</ol>
<pre><code>function f1(p1,p2){
        console.log(this,p1,p2)
    }
    let f2 = f1.bind({name:'frank'})
    //f2就是f1绑定了this之后的函数
    f2()
    //等价于f1.call({name:'frank'})
</code></pre><ol start="2">
<li>.bind 还可以绑定其他参数</li>
</ol>
<pre><code> let f3 = f1.bind({name:'frank'}，'hi')
 f3()//等价于f1.call({name:'frank'},'hi')
</code></pre></li>
<li>
<p>箭头函数（没有 this 和 arguments）</p>
</li>
</ul>
<pre><code>console.log(this)
//window
let a = () =&gt; console.log(this)
//箭头函数的this就是外部window的this，一个普通的变量
a.call(1)//箭头函数的this不能指定，还是外部的this，除非外部this改变
</code></pre><ul>
<li>立即执行函数（现在用的很少）</li>
</ul>
<p>获取局部变量，使用（）立即执行，只需要在匿名函数前加个运算符即可，推荐感叹号！</p>
<pre><code>! function (){
    var a =2
    console.log(a)
} ()//2，+，—可以，1* 也可以，只要加个运算
</code></pre><p>新版 JS 只需要 let 外加{ }即可</p>
<pre><code>{
    let a = 2
    console.log(2)
}//2
</code></pre><h2 id="note">Note:</h2>
<p>function 外有（）时，才会用；分隔开，也是唯一需要加分号的地方。</p>
<pre><code>console.log('hi');
(function (){
    var a =2
    console.log(a)
} ())
</code></pre>
    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>Author:</span>
                <span>隋鑫 </span>
                </p>
            
           
             
            <p class="copyright-item">
                    <span>Link:</span>
                    <a href=http://suixin.monster/js%E5%87%BD%E6%95%B0/>http://suixin.monster/js%E5%87%BD%E6%95%B0/</span>
            </p>
            
             
            <p class="copyright-item lincese">
                本文采用<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议</a>进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">back</a></span> · 
                <span><a href="http://suixin.monster/">home</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="http://suixin.monster/js%E6%95%B0%E7%BB%84/" class="prev" rel="prev" title="JS数组"><i class="iconfont icon-left"></i>&nbsp;JS数组</a>
         
        
        <a href="http://suixin.monster/js%E8%BF%90%E7%AE%97%E7%AC%A6/" class="next" rel="next" title="JS运算符">JS运算符&nbsp;<i class="iconfont icon-right"></i></a>
        
    </div>

    <div class="post-comment">
          
                 
          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2018 - 2020</span>
        
        <span class="with-love">
    	 <i class="iconfont icon-love"></i> 
         </span>
         
            <span class="author" itemprop="copyrightHolder"><a href="http://suixin.monster/">隋鑫</a> | </span> 
         

         
		  <span>Powered by <a href="https://gohugo.io/" target="_blank" rel="external nofollow">Hugo</a> & <a href="https://github.com/liuzc/leaveit" target="_blank" rel="external nofollow">LeaveIt</a></span> 
    </div>
</footer>












    
    
    <script src="/js/vendor_no_gallery.min.js" async=""></script>
    
  



     </div>
  </body>
</html>
